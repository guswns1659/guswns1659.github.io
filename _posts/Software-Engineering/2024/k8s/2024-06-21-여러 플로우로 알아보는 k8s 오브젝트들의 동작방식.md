---
title: 여러 플로우로 알아보는 k8s 오브젝트들의 동작방식
date: 2024-06-16 11:49:08 +09:00
categories: [Software-Engineering]
tags: engineering
---

이번 글에서는 여러 플로우를 통해서 k8s가 내부적으로 어떻게 동작하는지 알아보겠습니다. 각 플로우는 아래와 같습니다. 

- 하나의 Pod이 뜰 때 각 k8s 오브젝트가 어떻게 상호작용하는지

## 하나의 Pod이 뜰 때 각 k8s 오브젝트가 어떻게 상호작용하는지

![팟 생명주기](/assets/img/파드의%20생명주기.jpeg)

(Image source: [컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커](https://product.kyobobook.co.kr/detail/S000001834629))

1. kubectl을 통해 API 서버에 파드 생성을 요청합니다.
2. (업데이트가 있을 때마다 매번) API 서버에 전달된 내용이 있으면 API 서버는 etcd에 전달된
   내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지합니다. 따라서 각 요소가 상태를 업
   데이트할 때마다 모두 API 서버를 통해 etcd에 기록됩니다.
3. API 서버에 파드 생성이 요청된 것을 컨트롤러 매니저가 인지하면 컨트롤러 매니저는 파드를
   생성하고, 이 상태를 API 서버에 전달합니다. 참고로 아직 어떤 워커 노드에 파드를 적용할지
   는 결정되지 않은 상태로 파드만 생성됩니다.
4. API 서버에 파드가 생성됐다는 정보를 스케줄러가 인지합니다. 스케줄러는 생성된 파드를 어떤
   워커 노드에 적용할지 조건을 고려해 결정하고 해당 워커 노드에 파드를 띄우도록 요청합니다.
5. API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해 있는지 스케줄러가 kubelet으로 확인합니다. (공부한거랑 다름, -> 스케쥴러가 kubelet에 직접 호출하지 않고 kubelet도 watch 매커니즘으로 api 서버로부터 데이터를 받는 걸로 알고 있음)
7. kubelet에서 컨테이너 런타임으로 파드 생성을 요청합니다.
8. 파드가 생성됩니다.
9. 파드가 사용 가능한 상태가 됩니다.

### 등장하는 Kubernetes 오브젝트

1. **API 서버 (kube-apiserver)**
2. **etcd**
3. **컨트롤러 매니저 (kube-controller-manager)**
4. **스케줄러 (kube-scheduler)**
5. **kubelet**
6. **컨테이너 런타임 (Container Runtime)**

### 1. **API 서버 (kube-apiserver)**

![Kube-API-Server.jpg](/assets/img/Kube-API-Server.jpg)

(Image source: [https://www.simform.com/blog/kubernetes-architecture/](https://www.simform.com/blog/kubernetes-architecture/))

**역할**:
- Kubernetes의 핵심 컴포넌트로, 클러스터의 모든 상태를 관리하고, 클라이언트와 통신합니다.
- RESTful API를 제공하여 외부 요청을 받아들이고 처리합니다.
- 모든 클러스터 내의 구성 요소와의 통신 허브 역할을 합니다.

**상세 설명**:
- **중앙 관리**: API 서버는 클러스터의 중앙 관리 컴포넌트로, 모든 클러스터 구성 요소의 요청을 받아들이고, 이를 처리합니다.
- **인증 및 인가**: 사용자와 시스템의 요청을 인증하고 인가하여 보안을 유지합니다.
- **etcd와의 통신**: 클러스터의 상태 정보를 etcd에 저장하고, 필요 시 이를 가져옵니다.

### 2. **etcd**

![ETCD.jpg](/assets/img/ETCD.jpg)

(Image source: [https://www.simform.com/blog/kubernetes-architecture/](https://www.simform.com/blog/kubernetes-architecture/))

**역할**:
- 분산 키-값 저장소로, Kubernetes 클러스터의 모든 상태 데이터를 저장합니다.
- 영구 저장소로, 클러스터의 상태 정보를 신뢰성 있게 저장합니다.

**상세 설명**:
- **데이터 저장소**: etcd는 클러스터의 모든 구성 요소와 리소스의 상태 정보를 저장하는 분산 데이터베이스입니다.
- **고가용성**: 클러스터링을 통해 고가용성과 데이터 일관성을 유지합니다.
- **키-값 쌍**: 모든 데이터는 키-값 쌍의 형태로 저장되며, 빠른 검색이 가능합니다.

### 3. **컨트롤러 매니저 (kube-controller-manager)**

![Kubernetes-control-manager.jpg](/assets/img/Kubernetes-control-manager.jpg)

(Image source: [https://www.simform.com/blog/kubernetes-architecture/](https://www.simform.com/blog/kubernetes-architecture/))

**컨트롤러의 동작 원리**
- 컨트롤러는 주기적으로 API 서버에서 리소스의 현재 상태를 읽고, 이를 원하는 상태와 비교합니다. 만약 현재 상태가 원하는 상태와 일치하지 않으면, 컨트롤러는 필요한 조치를 취하여 일관성을 유지합니다.
- Deployment Controller, DaemonSet Controller 등

#### (예시) Deployment Controller

**목적**:
- 애플리케이션 배포와 관리를 위해 사용됩니다.
- 여러 복제본의 애플리케이션을 배포하고, 배포 전략을 적용하여 점진적인 롤아웃(rollout)이나 롤백(rollback)을 지원합니다.

**특징**:
- **복제 관리**: 지정된 수의 Pod 복제본이 항상 실행되도록 보장합니다.
- **전략적 배포**: RollingUpdate, Recreate 등의 배포 전략을 지원하여 애플리케이션을 무중단으로 업데이트할 수 있습니다.

### 4. **스케줄러 (kube-scheduler)**

**역할**:
- 생성된 Pod을 적절한 워커 노드에 할당합니다.
- 클러스터의 리소스 사용을 최적화하고, Pod의 요구 사항을 만족시키는 노드를 선택합니다.

**상세 설명**:
- **노드 선택**: 스케줄러는 클러스터 내의 모든 노드의 상태와 리소스 사용량을 고려하여, 각 Pod에 가장 적합한 노드를 선택합니다.
- **리소스 요구 사항**: 각 Pod의 리소스 요구 사항(CPU, 메모리 등)을 고려하여 노드를 선택합니다.
- **스케줄링 알고리즘**: 다양한 스케줄링 알고리즘을 사용하여 최적의 노드를 선택합니다.

### 5. **kubelet**

![kubelet.jpg](/assets/img/kubelet.jpg)

(Image source: [https://www.simform.com/blog/kubernetes-architecture/](https://www.simform.com/blog/kubernetes-architecture/))

**역할**:
- 각 워커 노드에서 실행되며, API 서버와 통신하여 Pod을 실행하고 상태를 보고합니다.
- 노드에서 컨테이너를 관리하고, 실행 상태를 모니터링합니다.

**상세 설명**:
- **Pod 실행**: kubelet은 API 서버로부터 받은 Pod 정의를 실행하고, 컨테이너 런타임을 통해 실제 컨테이너를 관리합니다.
- **상태 보고**: 주기적으로 API 서버에 노드와 Pod의 상태를 보고하여 클러스터의 최신 상태를 유지합니다.
- **건강 체크**: 노드와 Pod의 상태를 모니터링하고, 문제가 발생하면 이를 보고합니다.

#### CNI (Container Network Interface)란?

CNI는 Container Network Interface의 약자로, 컨테이너 네트워킹을 설정하고 관리하기 위한 표준 인터페이스입니다. 이는 컨테이너 오케스트레이션 시스템(예: Kubernetes)과 네트워크 플러그인 간의 표준 인터페이스를 정의합니다. CNI는 컨테이너 네트워크 설정과 네트워크 자원의 할당 및 해제를 담당합니다.

#### 주요 개념 및 역할

1. **네트워크 설정**:
   - 컨테이너가 생성될 때 네트워크 인터페이스를 설정하고, 필요한 네트워크 자원을 할당합니다.
   - 각 컨테이너가 고유한 네트워크 네임스페이스에서 실행될 수 있도록 보장합니다.

2. **네트워크 플러그인**:
   - 다양한 네트워크 플러그인이 CNI 표준을 구현하여 네트워킹 기능을 제공합니다. 
   - 플러그인은 네트워크 정책, IPAM(IP Address Management), 라우팅 등을 관리합니다.


### 6. **컨테이너 런타임 (Container Runtime)**

![container-runtime-architecture.jpg](/assets/img/container-runtime-architecture.jpg)

(Image source: [https://www.simform.com/blog/kubernetes-architecture/](https://www.simform.com/blog/kubernetes-architecture/))

**역할**:
- 컨테이너를 실제로 실행하고 관리하는 소프트웨어입니다.
- Docker, containerd, CRI-O 등 다양한 컨테이너 런타임이 있습니다.

**상세 설명**:
- **컨테이너 실행**: kubelet의 명령을 받아 컨테이너를 실행하고, 라이프사이클을 관리합니다.
- **이미지 관리**: 컨테이너 이미지를 다운로드하고, 필요한 경우 업데이트합니다.
- **네트워킹**: 각 컨테이너에 네트워크를 설정하고, 클러스터 내의 다른 컨테이너와 통신할 수 있도록 합니다.
